/**
 * Autogenerated UI for Grasshopper definitions
 * 
 * Routes:
 *  ('/')
 *     Show list of available definitions
 *  ('/:definition')
 *     Show autogenerated ui for definition
 */
const express = require('express')
const router = express.Router()
const getParams = require('../definitions.js').getParams

router.get('/', (req, res) => {
  res.send('This is the fixed string response for /deflib')
})

function extractValue(defaultValue) {
  const data = defaultValue?.innerTree[Object.keys(defaultValue.innerTree)[0]][0].data;
  return data;
}

/**
 * Parse the URL into a list of objects { owner, repo, slug, version }
 * Example input: /deflib/nicolaasburgers+test09+cube+1;janedoe+example+sphere+2
 */
function parseDeflibUrl(url) {
  const sets = url.split(';');  // Split by semicolon to get each set
  return sets.map(set => {
      const [owner, repo, slug, version] = set.split('+');  // Split by plus sign
      return { owner, repo, slug, version: version || 'latest' };  // Default to 'latest' if version is missing
  });
}

router.get('/*', async (req, res, next) => {
  const urlPart = req.url.substring(req.url.indexOf('/') + 1);  // Remove the "/deflib/" part of the URL
  const parsedDefinitions = parseDeflibUrl(urlPart);  // Parse the URL
  
  const def = parsedDefinitions[0]; // Just do the first specified one only so far
  const defKey = `${def.owner}+${def.repo}+${def.slug}+${def.version}`;
  const fullUrl = `https://raw.githubusercontent.com/${def.owner}/${def.repo}/main/gh/${def.slug}.gh`;

  let definitions = req.app.get('definitions');
  let definition = definitions.find(o => o.name === defKey)

  if (definition == null) {
    // Add to cache so that the solve endpoint can find it
    definition = {
      name: defKey,
      path: fullUrl
    }
    definitions.push(definition);
  }

  if (!Object.prototype.hasOwnProperty.call(definition, 'inputs')
      && !Object.prototype.hasOwnProperty.call(definition, 'outputs')) {
    let data
    try {
      data = await getParams(fullUrl)
    } catch (err) {
      next(err)
    }

    // cache
    definition.description = data.description
    definition.inputs = data.inputs
    definition.outputs = data.outputs
  }

  const versionString = def.version && def.version > 0 ? `v${def.version}` : '(latest)';
  const pageTitle = `${def.slug} ${versionString}`;
  
  view = {
    name: definition.name,
    title: pageTitle,
    inputs: []
  }

  for (const input of definition.inputs) {
    const name = input.name
    const id = name
    switch (input.paramType) {
      case 'Integer':
        view.inputs.push({
          name: name,
          id: id,
          number: {
            value: extractValue(input.default)
          }
        })
        break;
      case 'Number':
        if (input.minimum !== undefined && input.minimum !== null
            && input.maximum !== undefined && input.maximum !== null)
        {

          let step = 1
          if( ( input.maximum - input.minimum ) < 1 ) {
            step = 0.1
          }
          // use range input if min and max set
          view.inputs.push({
            name: name,
            id: id,
            range: {
              min: input.minimum,
              max: input.maximum,
              value: extractValue(input.default),
              step: step
            }
          })
        } else {
          // otherwise use number input
          view.inputs.push({
            name: name,
            id: id,
            number: {
              value: extractValue(input.default)
            }
          })
        }
        break
      case 'Boolean':
        view.inputs.push({
          name: name,
          id: id,
          bool: {
            value: extractValue(input.default)
          }
        })
        break
    }
  }

  res.render('deflib', view)
})

module.exports = router
